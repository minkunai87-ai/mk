<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>ë‚˜ë§Œì˜ ì•ˆí‚¤ (êµ¬ì¡° ë³´ì¡´ ë° ë³µêµ¬)</title>
<style>
    /* ë””ìì¸: ë‹¤í¬ëª¨ë“œ + ì•„ì´í° í• + íŠ¸ë¦¬êµ¬ì¡° ìŠ¤íƒ€ì¼ */
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    :root { --primary: #4dabf7; --bg: #121212; --surface: #1e1e1e; --text: #e0e0e0; --text-sub: #a0a0a0; --border: #333333; --input-bg: #2c2c2c; --btn-hover: #383838; --sub-group-bg: #252525; }
    body { font-family: 'Apple SD Gothic Neo', sans-serif; background: var(--bg); color: var(--text); margin: 0; display: flex; flex-direction: column; height: 100dvh; overflow: hidden; }
    
    .header { background: var(--surface); padding: 0 20px; padding-top: calc(env(safe-area-inset-top) + 15px); padding-bottom: 15px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--border); z-index: 10; flex-shrink: 0; position: relative; }
    .header-title { font-weight: bold; font-size: 1.15rem; color: var(--text); overflow: hidden; white-space: nowrap; text-overflow: ellipsis; max-width: 60%; }
    .header-controls { display: flex; gap: 10px; align-items: center; }
    .menu-btn { font-size: 1.6rem; cursor: pointer; background: none; border: none; padding: 0; color: var(--text); display: flex; align-items: center; }
    .counter { font-size: 0.85rem; font-weight: bold; color: var(--text-sub); background: var(--input-bg); padding: 5px 12px; border-radius: 15px; }

    .sidebar { position: fixed; top: 0; left: 0; width: 300px; height: 100%; background: var(--surface); border-right: 1px solid var(--border); box-shadow: 2px 0 15px rgba(0,0,0,0.5); transition: transform 0.3s ease; z-index: 9999; padding: 25px; padding-top: calc(env(safe-area-inset-top) + 25px); display: flex; flex-direction: column; overflow-y: auto; transform: translateX(-105%); }
    .sidebar.open { transform: translateX(0); }
    .sidebar-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 9998; display: none; }
    .sidebar-overlay.open { display: block; }
    
    .menu-section { margin-bottom: 20px; border-bottom: 1px solid var(--border); padding-bottom: 15px; }
    .menu-label { font-weight: bold; color: var(--text-sub); margin-bottom: 10px; display: block; font-size: 0.95rem; }
    .search-box { position: relative; margin-bottom: 15px; }
    .search-input { width: 100%; padding: 12px 10px 12px 35px; border: 1px solid var(--border); background: var(--input-bg); color: var(--text); border-radius: 8px; font-size: 0.95rem; }
    .search-input:focus { border-color: var(--primary); outline: none; }
    .search-icon { position: absolute; left: 10px; top: 50%; transform: translateY(-50%); color: var(--text-sub); }

    .deck-list { list-style: none; padding: 0; margin: 0; }
    
    /* íŠ¸ë¦¬ êµ¬ì¡° */
    .tree-folder { margin-bottom: 4px; }
    .tree-header { 
        display: flex; justify-content: space-between; align-items: center;
        padding: 10px; border-radius: 8px; cursor: pointer;
        background: var(--input-bg); border: 1px solid var(--border);
        transition: 0.2s; margin-bottom: 4px;
    }
    .tree-header:hover { background: var(--btn-hover); }
    .tree-children { display: none; padding-left: 10px; margin-left: 8px; border-left: 2px solid #444; }
    .tree-children.open { display: block; }
    .folder-title { flex: 1; font-weight: bold; color: #ffd43b; font-size: 0.95rem; display: flex; align-items: center; gap: 6px; }
    
    .tree-deck { 
        padding: 12px; border-radius: 8px; cursor: pointer; 
        background: var(--input-bg); margin-bottom: 4px; color: var(--text); font-size: 0.9rem;
        display: flex; justify-content: space-between; align-items: center;
    }
    .tree-deck.active { background: #182836; color: #74c0fc; font-weight: bold; border: 1px solid #1c7ed6; }
    
    .play-btn { background: var(--primary); color: white; border: none; padding: 4px 8px; border-radius: 4px; font-size: 0.75rem; font-weight: bold; cursor: pointer; margin-left: 8px; }
    .del-btn { background: none; border: none; color: var(--text-sub); font-weight: bold; padding: 0 5px; cursor: pointer; font-size: 1rem; }

    .btn-upload, .sort-btn, .backup-btn, .restore-btn, .refresh-btn { width: 100%; padding: 12px; margin-bottom: 8px; border-radius: 8px; cursor: pointer; font-weight: bold; border: 1px solid var(--border); background: var(--input-bg); color: var(--text); text-align: left; }
    .btn-upload { background: var(--primary); color: white; border: none; text-align: center; }
    .backup-btn { background: #343a40; color: white; border: none; text-align: center; }
    .restore-btn { background: #495057; color: white; border: none; text-align: center; }
    .refresh-btn { background: #212529; color: var(--text-sub); border: 1px solid var(--border); text-align: center; margin-top: 10px; }

    .main-container { flex: 1; display: flex; flex-direction: column; padding: 0; width: 100%; position: relative; overflow: hidden; background: var(--bg); }
    .card { background: var(--surface); width: 100%; height: 100%; max-width: none; border-radius: 0; box-shadow: none; border: none; display: flex; flex-direction: column; position: relative; overflow: hidden; }
    .card-scroll-area { flex: 1; padding: 25px 20px; overflow-y: auto; scrollbar-width: thin; scrollbar-color: var(--border) var(--bg); }
    .card-info { display: flex; justify-content: space-between; width: 100%; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px dashed var(--border); align-items: center; }
    .rate-badge { font-size: 0.8rem; font-weight: bold; padding: 4px 8px; border-radius: 6px; background: var(--input-bg); color: var(--text-sub); }
    .rate-badge.high { background: #0b2e13; color: #69db7c; } .rate-badge.low { background: #2e0b0b; color: #ff8787; }
    
    .icon-wrapper { display: flex; flex-direction: column; gap: 5px; align-items: flex-end; }
    .icon-row { display: flex; gap: 12px; }
    .icon-btn { font-size: 1.4rem; cursor: pointer; background: none; border: none; padding: 0; line-height: 1; color: var(--text-sub); transition: 0.2s; opacity: 0.4; filter: grayscale(100%); }
    .icon-btn:hover { opacity: 0.8; }
    .icon-btn.active { opacity: 1; filter: grayscale(0%); transform: scale(1.1); }
    .mem-btn.active { color: #ff8787; } .cmp-btn.active { color: #74c0fc; } .fav-btn.active { color: #ffd43b; }
    .num-btn.active { color: #66d9e8; } .date-btn.active { color: #b197fc; } .pen-btn.active { color: #ff6b6b; }
    .edit-btn { font-size: 1.2rem; margin-right: 5px; opacity: 1; color: var(--text-sub); }

    /* ğŸ”¥ ë³¸ë¬¸ ìŠ¤íƒ€ì¼ (ì´ë¯¸ì§€ ì˜¤í´ë£¨ì „ ì™„ë²½ í˜¸í™˜) */
    .text-area { 
        font-size: 1.35rem; line-height: 1.6; word-break: keep-all; white-space: pre-wrap; 
        width: 100%; margin-bottom: 20px; color: var(--text); font-weight: 500; 
        position: relative; /* ì˜¤í´ë£¨ì „ ê¸°ì¤€ì  */
    }
    .text-area img { max-width: 100%; height: auto; border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.3); display: block; margin: 10px 0; }

    .divider { display: none; border: 0; border-top: 2px dashed var(--border); margin: 30px 0; position: relative; }
    .divider::after { content: "ì •ë‹µ"; position: absolute; top: -12px; left: 50%; transform: translateX(-50%); background: var(--surface); padding: 0 10px; color: var(--text-sub); font-size: 0.8rem; font-weight: bold; }
    #answer-section { display: none; padding-bottom: 20px; animation: fadeIn 0.3s ease-in-out; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

    .footer { width: 100%; padding: 10px 20px; padding-bottom: calc(35px + env(safe-area-inset-bottom)); background: var(--surface); border-top: 1px solid var(--border); z-index: 10; display: flex; flex-direction: column; gap: 10px; justify-content: center; flex-shrink: 0; box-shadow: 0 -5px 15px rgba(0,0,0,0.1); }
    .nav-btns, .grade-btns { display: flex; justify-content: space-between; width: 100%; margin: 0; gap: 12px; }
    .nav-btn { flex: 1; background: var(--input-bg); border: 1px solid var(--border); padding: 14px 0; border-radius: 12px; cursor: pointer; font-weight: bold; color: var(--text); font-size: 1rem; text-align: center; transition: 0.2s; }
    .nav-btn:active { background: var(--btn-hover); }
    .g-btn { flex: 1; padding: 16px 0; border: none; border-radius: 12px; font-weight: bold; color: white; cursor: pointer; font-size: 1.1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.2); margin: 0; text-align: center; }
    .g-btn:active { transform: scale(0.98); opacity: 0.9; }
    .bg-x { background: #fa5252; } .bg-tri { background: #fab005; } .bg-o { background: #40c057; }

    .click-guide { text-align: center; color: var(--text-sub); font-size: 0.9rem; margin-top: 40px; cursor: pointer; padding: 30px; border: 2px dashed var(--border); border-radius: 12px; background: #181818; }
    .click-guide:active { background: #222; }

    .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10000; display: none; align-items: center; justify-content: center; }
    .modal-content { background: var(--surface); width: 90%; max-width: 500px; padding: 25px; border-radius: 15px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); display: flex; flex-direction: column; gap: 15px; border: 1px solid var(--border); }
    .modal-title { font-weight: bold; font-size: 1.2rem; color: var(--text); }
    .edit-label { font-size: 0.9rem; color: var(--text-sub); font-weight: bold; }
    .edit-input { width: 100%; padding: 10px; border: 1px solid var(--border); background: var(--input-bg); color: var(--text); border-radius: 8px; font-family: inherit; font-size: 1rem; resize: vertical; min-height: 80px; }
    .modal-btns { display: flex; justify-content: flex-end; gap: 10px; margin-top: 10px; }
    .modal-btn { padding: 10px 20px; border-radius: 8px; border: none; font-weight: bold; cursor: pointer; }
    .btn-save { background: var(--primary); color: white; } .btn-cancel { background: var(--input-bg); color: var(--text); }
    
    #loading { margin-top: 50%; color: var(--text-sub); text-align: center; }
    .ox-highlight { font-size: 4rem; font-weight: 900; text-align: center; display: block; margin: 10px 0; }
    .ox-o { color: #40c057; } .ox-x { color: #fa5252; }
</style>
</head>
<body>

    <div class="sidebar-overlay" onclick="toggleMenu()"></div>
    <div class="sidebar" id="sidebar">
        <h2 style="margin-top:0; color:var(--text); font-size:1.4rem;">âš™ï¸ ë©”ë‰´</h2>
        
        <div class="menu-section">
            <span class="menu-label">ğŸ” ì¹´ë“œ ê²€ìƒ‰</span>
            <div class="search-box">
                <span class="search-icon">ğŸ”</span>
                <input type="text" id="search-input" class="search-input" placeholder="í…ìŠ¤íŠ¸, OCR, íƒœê·¸ ê²€ìƒ‰" onkeyup="filterCards()">
            </div>
        </div>

        <div class="menu-section">
            <span class="menu-label">í•„í„° ë° ëª¨ì•„ë³´ê¸°</span>
            <button class="sort-btn" onclick="sortCards('default')"><span>ğŸ“‹ ì „ì²´ ë³´ê¸° (ê¸°ë³¸)</span></button>
            <div style="height:10px;"></div>
            <button class="sort-btn" onclick="sortCards('mem')"><span>ğŸ§  ì•”ê¸°ì¥ ëª¨ìŒ</span></button>
            <button class="sort-btn" onclick="sortCards('cmp')"><span>ğŸ†š ë¹„êµë¬¸ì œ ëª¨ìŒ</span></button>
            <button class="sort-btn" onclick="sortCards('fav')"><span>â­ ì¤‘ìš”(ë³„í‘œ) ëª¨ìŒ</span></button>
            <div style="height:10px;"></div>
            <button class="sort-btn" onclick="sortCards('num')"><span>ğŸ”¢ ìˆ«ìë¬¸ì œ ëª¨ìŒ</span></button>
            <button class="sort-btn" onclick="sortCards('date')"><span>ğŸ“… ë‚ ì§œ/ê¸°í•œ ëª¨ìŒ</span></button>
            <button class="sort-btn" onclick="sortCards('pen')"><span>ğŸš¨ ë²Œì¹™/ë²Œê¸ˆ ëª¨ìŒ</span></button>
            <div style="height:10px;"></div>
            <button class="sort-btn" style="border-color:#ff6b6b; color:#ff8787;" onclick="sortCards('rate_asc')"><span>ğŸ”¥ ì˜¤ë‹µ ë…¸íŠ¸</span></button>
        </div>

        <div class="menu-section">
            <span class="menu-label">ë± ê´€ë¦¬</span>
            <div style="font-size:0.8rem; color:var(--text-sub); margin-bottom:5px;">
                * <b>minkunai87-ai/mk</b> ìë™ ì—°ë™ ì¤‘
            </div>
            <button class="btn-upload" onclick="document.getElementById('file-input').click()">+ (ë¡œì»¬) í…ìŠ¤íŠ¸ íŒŒì¼ ì¶”ê°€</button>
            <input type="file" id="file-input" accept=".txt" multiple style="display:none" onchange="handleFileUpload(this)">
            <ul class="deck-list" id="deck-list-ui"></ul>
        </div>

        <div class="menu-section">
            <span class="menu-label">ë°ì´í„° ë°±ì—…/ë³µêµ¬</span>
            <button class="backup-btn" onclick="exportData()">ğŸ’¾ ë°±ì—… íŒŒì¼ ì €ì¥</button>
            <button class="restore-btn" onclick="document.getElementById('backup-input').click()">ğŸ“‚ ë°±ì—… íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸°</button>
            <input type="file" id="backup-input" accept=".json" style="display:none" onchange="importData(this)">
        </div>

        <div class="menu-section">
            <span class="menu-label">ì´ë¯¸ì§€ ì„¤ì •</span>
            <button class="btn-upload" style="background:#20c997;" onclick="document.getElementById('img-input').click()">ğŸ–¼ï¸ ì´ë¯¸ì§€ í´ë” ì—°ê²°</button>
            <input type="file" id="img-input" webkitdirectory directory multiple style="display:none" onchange="handleImgUpload(this)">
        </div>

        <div style="margin-top:20px; padding-bottom:30px;">
            <button class="refresh-btn" onclick="location.reload()">ğŸ”„ ì‚¬ì´íŠ¸ ìƒˆë¡œê³ ì¹¨</button>
        </div>
        
        <div style="margin-top:auto; font-size:0.8rem; color:var(--text-sub); text-align:center;">
            My Anki v10.18 (Restore & Sanitize)
        </div>
    </div>

    <div class="header">
        <button class="menu-btn" onclick="toggleMenu()">â˜°</button>
        <div class="header-title" id="deck-title">ë‚˜ë§Œì˜ ì•ˆí‚¤</div>
        <div class="header-controls">
            <span class="counter" id="card-counter">0 / 0</span>
        </div>
    </div>

    <div class="main-container">
        <div class="card">
            <div class="card-scroll-area" id="scroll-area">
                <div id="loading" style="display:none;">ë°ì´í„° ë¡œë”© ì¤‘...</div>
                
                <div class="card-info" id="card-info">
                    <span class="rate-badge" id="rate-badge">New</span>
                    <div class="icon-wrapper">
                        <div class="icon-row">
                            <button class="icon-btn edit-btn" onclick="openEditModal(event)">âœï¸</button>
                            <button class="icon-btn mem-btn" id="mem-btn" onclick="toggleTag(event, 'mem')" title="ì•”ê¸°">ğŸ§ </button>
                            <button class="icon-btn cmp-btn" id="cmp-btn" onclick="toggleTag(event, 'cmp')" title="ë¹„êµ">ğŸ†š</button>
                            <button class="icon-btn fav-btn" id="fav-btn" onclick="toggleTag(event, 'fav')" title="ì¤‘ìš”">â­</button>
                        </div>
                        <div class="icon-row">
                            <button class="icon-btn num-btn" id="num-btn" onclick="toggleTag(event, 'num')" title="ìˆ«ì">ğŸ”¢</button>
                            <button class="icon-btn date-btn" id="date-btn" onclick="toggleTag(event, 'date')" title="ë‚ ì§œ">ğŸ“…</button>
                            <button class="icon-btn pen-btn" id="pen-btn" onclick="toggleTag(event, 'pen')" title="ë²Œì¹™">ğŸš¨</button>
                        </div>
                    </div>
                </div>

                <div id="question-section" class="content-box">
                    <h3 style="color:var(--text-sub);" id="guide-msg">ğŸ‘ˆ ë©”ë‰´ì—ì„œ íŒŒì¼ì„ ì¶”ê°€í•´ì£¼ì„¸ìš”.</h3>
                </div>

                <div id="click-guide" class="click-guide" onclick="revealAnswer()">
                    ğŸ‘‡ í„°ì¹˜í•˜ì—¬ ì •ë‹µ í™•ì¸
                </div>

                <hr id="divider" class="divider">

                <div id="answer-section" class="content-box"></div>
            </div>
        </div>
    </div>

    <div class="footer">
        <div class="grade-btns" id="grade-area">
            <button class="g-btn bg-x" onclick="grade(0)">ëª¨ë¦„</button>
            <button class="g-btn bg-tri" onclick="grade(1)">ì• ë§¤</button>
            <button class="g-btn bg-o" onclick="grade(2)">ë§ìŒ</button>
        </div>
        <div class="nav-btns" id="nav-area">
            <button class="nav-btn" onclick="moveCard(-1)">â—€ ì´ì „</button>
            <button class="nav-btn" onclick="moveCard(1)">ë‹¤ìŒ â–¶</button>
        </div>
    </div>

    <div class="modal-overlay" id="edit-modal">
        <div class="modal-content">
            <div class="modal-title">ğŸ“ ì¹´ë“œ ìˆ˜ì •</div>
            <div><span class="edit-label">ì§ˆë¬¸ (Front)</span><textarea id="edit-q" class="edit-input"></textarea></div>
            <div><span class="edit-label">ì •ë‹µ (Back)</span><textarea id="edit-a" class="edit-input"></textarea></div>
            <div class="modal-btns">
                <button class="modal-btn btn-cancel" onclick="closeEditModal()">ì·¨ì†Œ</button>
                <button class="modal-btn btn-save" onclick="saveEdit()">ì €ì¥</button>
            </div>
        </div>
    </div>

<script>
    const repoOwner = 'minkunai87-ai';
    const repoName = 'mk';

    let library = {}, currentDeckName = null, originalDeck = [], activeDeck = [], currentIndex = 0;
    let imageMap = new Map(), isRevealed = false;
    const STORAGE_KEY_LIBRARY = 'anki_final_library';
    const STORAGE_KEY_STATS = 'anki_final_stats';
    const STORAGE_KEY_EDITS = 'anki_final_edits';
    const STORAGE_KEY_PROGRESS = 'anki_final_progress';
    const STORAGE_KEY_LAST_DECK = 'anki_final_last_deck';

    window.onload = async function() {
        if (location.protocol.startsWith('http')) { await autoScanGitHub(); }
        else { loadLocalLibrary(); }
    };

    function loadLocalLibrary() {
        const savedLib = localStorage.getItem(STORAGE_KEY_LIBRARY);
        if (savedLib) {
            try {
                library = JSON.parse(savedLib);
                renderDeckTree();
                const lastDeck = localStorage.getItem(STORAGE_KEY_LAST_DECK);
                if (lastDeck) {
                    if (library[lastDeck]) selectDeck(lastDeck);
                    else selectDeckGroup(lastDeck);
                } else {
                    const keys = Object.keys(library);
                    if(keys.length > 0) selectDeck(keys[0]);
                }
            } catch(e) {}
        }
    }

    async function autoScanGitHub() {
        document.getElementById('loading').style.display = 'block';
        document.getElementById('question-section').style.display = 'none';
        let loadedCount = 0; const edits = JSON.parse(localStorage.getItem(STORAGE_KEY_EDITS) || '{}');
        try {
            const listUrl = `https://api.github.com/repos/${repoOwner}/${repoName}/contents/`;
            const listResponse = await fetch(listUrl);
            if (!listResponse.ok) throw new Error("Repo access failed");
            const files = await listResponse.json();
            const txtFiles = files.filter(f => f.name.endsWith('.txt'));
            for (const file of txtFiles) {
                try {
                    const contentResponse = await fetch(file.download_url + '?t=' + new Date().getTime());
                    const text = await contentResponse.text();
                    processAnkiText(text, file.name, edits);
                    loadedCount++;
                } catch (e) { console.error("Error reading file:", file.name); }
            }
        } catch (error) { console.error("Auto scan failed:", error); }
        renderDeckTree();
        document.getElementById('loading').style.display = 'none';
        document.getElementById('question-section').style.display = 'block';
        if (loadedCount > 0) {
            const lastDeck = localStorage.getItem(STORAGE_KEY_LAST_DECK);
            if (lastDeck) {
                if (library[lastDeck]) selectDeck(lastDeck);
                else selectDeckGroup(lastDeck);
            } else { selectDeck(Object.keys(library)[0]); }
        } else { document.getElementById('question-section').innerHTML = "<h3>âš ï¸ ë¶ˆëŸ¬ì˜¬ ë±ì´ ì—†ìŠµë‹ˆë‹¤.</h3>"; }
    }

    // TSV íŒŒì„œ (ì•ˆì •ì„± í™•ë³´)
    function parseAnkiRawData(str) {
        const rows = []; let currentRow = []; let currentCell = ''; let cursor = 0; let inQuote = false;
        while (cursor < str.length) {
            const char = str[cursor]; const nextChar = str[cursor + 1];
            if (inQuote) {
                if (char === '"' && nextChar === '"') { currentCell += '"'; cursor += 2; } 
                else if (char === '"') { inQuote = false; cursor++; } 
                else { currentCell += char; cursor++; }
            } else {
                if (char === '"') { inQuote = true; cursor++; } 
                else if (char === '\t') { currentRow.push(currentCell); currentCell = ''; cursor++; } 
                else if (char === '\n' || char === '\r') {
                    if (char === '\r' && nextChar === '\n') cursor++;
                    currentRow.push(currentCell);
                    if (currentRow.length > 1 || (currentRow.length === 1 && currentRow[0].trim() !== '')) { rows.push(currentRow); }
                    currentRow = []; currentCell = ''; cursor++;
                } else { currentCell += char; cursor++; }
            }
        }
        if (currentRow.length > 0 || currentCell !== '') { currentRow.push(currentCell); rows.push(currentRow); }
        return rows;
    }

    function processAnkiText(text, filename, edits) {
        const rows = parseAnkiRawData(text);
        let currentDeck = filename.replace('.txt', '');

        rows.forEach(fields => {
            if (fields.length > 0 && fields[0].startsWith('#')) return;
            let deckNameInRow = null; let q = "", a = "";
            
            // 3ì¹¼ëŸ¼(ë±,ì§ˆë¬¸,ë‹µ) êµ¬ì¡° ì²˜ë¦¬
            if (fields.length >= 3) {
                deckNameInRow = fields[0].replace(/::/g, '__');
                q = fields[1]; a = fields.slice(2).join('<br>');
            } else {
                deckNameInRow = currentDeck;
                if (fields.length === 2) { q = fields[0]; a = fields[1]; } 
                else if (fields.length > 0) { q = fields[0]; a = fields.slice(1).join('<br>'); }
            }
            if(!q) return;
            if (!library[deckNameInRow]) library[deckNameInRow] = [];
            
            const id = cyrb53(q);
            if (edits[id]) { q = edits[id].q; a = edits[id].a; }
            
            // íˆ¬ëª… ê²€ìƒ‰ì–´(OCR) ì¶”ì¶œ
            let hiddenText = "";
            const titleMatch = q.match(/title="([\s\S]*?)"/);
            if (titleMatch) hiddenText = titleMatch[1];

            library[deckNameInRow].push({ id, q, a, hiddenText });
        });
    }

    // === ğŸ”¥ í•µì‹¬ ìˆ˜ì •: HTML êµ¬ì¡° ë³´ì¡´í•˜ë©´ì„œ titleë§Œ ì œê±° + ì´ë¯¸ì§€ ì—°ê²° ===
    function createDOM(rawText, isAnswer) {
        // 1. ë”°ì˜´í‘œ ì–¸ì´ìŠ¤ì¼€ì´í”„
        let formattedText = rawText.replace(/""/g, '"');
        if (formattedText.startsWith('"') && formattedText.endsWith('"')) formattedText = formattedText.slice(1, -1);

        // 2. [ì´ë¯¸ì§€ ì˜¤í´ë£¨ì „ ì§€ì›] í…ìŠ¤íŠ¸ ì „ì²´ì—ì„œ ì´ë¯¸ì§€ëª… -> Blob URLë¡œ êµì²´
        // src="..." ë¿ë§Œ ì•„ë‹ˆë¼, style="background: url(...)" ë“±ë„ ì²˜ë¦¬í•˜ê¸° ìœ„í•´ ì „ì—­ ì¹˜í™˜
        const regex = /([a-zA-Z0-9_\-\.\%\(\)\s\uAC00-\uD7A3]+\.(jpg|jpeg|png|gif|svg|webp))/gi;
        
        let processedText = formattedText.replace(regex, (match) => {
            let fname = match.trim();
            // ì´ë¯¸ì§€ë§µì—ì„œ URL ì°¾ê¸°
            let url = imageMap.get(fname) || imageMap.get(fname.normalize('NFC')) || imageMap.get(fname.normalize('NFD'));
            if (url) return url;
            return match; // ì—†ìœ¼ë©´ ê·¸ëŒ€ë¡œ
        });

        // 3. DOM ìƒì„± (êµ¬ì¡° ìœ ì§€)
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = processedText;

        // 4. [ì²­ì†Œ] ëª¨ë“  ìš”ì†Œì—ì„œ title ì†ì„± ì œê±° (ë”ëŸ¬ìš´ ê¸€ì ìˆ¨ê¸°ê¸°)
        const allElements = tempDiv.querySelectorAll('*');
        allElements.forEach(el => {
            if (el.hasAttribute('title')) {
                el.removeAttribute('title');
            }
        });

        // 5. í™”ë©´ êµ¬ì„±
        const wrapper = document.createElement('div'); wrapper.className = 'answer-layout';
        const txtDiv = document.createElement('div'); txtDiv.className = 'text-area';
        
        // ì •ë‹µ O/X ê°•ì¡° (í…ìŠ¤íŠ¸ë§Œ ì¶”ì¶œí•´ì„œ í™•ì¸)
        let textContent = tempDiv.textContent.trim();
        
        // ë§Œì•½ ì •ë‹µì´ O/Xë¡œ ì‹œì‘í•˜ê³ , ë³µì¡í•œ íƒœê·¸(ì˜¤í´ë£¨ì „ div ë“±)ê°€ ì—†ëŠ” ë‹¨ìˆœ í…ìŠ¤íŠ¸ë¼ë©´ ê°•ì¡° ì ìš©
        // (ì˜¤í´ë£¨ì „ ì¹´ë“œê°€ ê¹¨ì§€ì§€ ì•Šê²Œ í•˜ê¸° ìœ„í•¨)
        const hasComplexTags = tempDiv.querySelector('div, svg'); 
        
        if (isAnswer && !hasComplexTags && (textContent.startsWith('O') || textContent.startsWith('X'))) {
             const firstChar = textContent.charAt(0);
             const oxSpan = document.createElement('span'); 
             oxSpan.className = `ox-highlight ${firstChar === 'O' ? 'ox-o' : 'ox-x'}`; 
             oxSpan.innerText = firstChar;
             
             txtDiv.appendChild(oxSpan);
             // O/X ëº€ ë‚˜ë¨¸ì§€ ë‚´ìš© (ì´ë¯¸ì§€ í¬í•¨)
             // ì—¬ê¸°ì„œ ì²« ê¸€ìë¥¼ ì œê±°í•˜ëŠ” ê±´ DOM êµ¬ì¡°ìƒ ë³µì¡í•˜ë¯€ë¡œ, 
             // O/XëŠ” ìœ„ì— í¬ê²Œ ë³´ì—¬ì£¼ê³ , ì•„ë˜ì—ëŠ” ì›ë³¸(O/X í¬í•¨)ì„ ê·¸ëŒ€ë¡œ ë³´ì—¬ì£¼ëŠ” ë°©ì‹ ì„ íƒ (ì•ˆì „ë¹µ)
             wrapper.appendChild(txtDiv);
             wrapper.appendChild(tempDiv);
        } else {
            // ì¼ë°˜ ì¹´ë“œ or ì˜¤í´ë£¨ì „ ì¹´ë“œ -> ê·¸ëƒ¥ í†µìœ¼ë¡œ ë³´ì—¬ì¤Œ
            wrapper.appendChild(tempDiv);
        }

        return wrapper;
    }

    // ... ê¸°ì¡´ í•¨ìˆ˜ë“¤ ...
    function renderDeckTree() {
        const list = document.getElementById('deck-list-ui'); list.innerHTML = '';
        const names = Object.keys(library).sort();
        if (names.length === 0) { list.innerHTML = '<li class="deck-item" style="justify-content:center;">ë± ì—†ìŒ</li>'; return; }
        const tree = {};
        names.forEach(path => {
            const parts = path.split('__'); let currentLevel = tree;
            parts.forEach((part, index) => {
                if (!currentLevel[part]) { currentLevel[part] = { _name: part, _fullPath: parts.slice(0, index + 1).join('__'), _children: {}, _isLeaf: false }; }
                if (index === parts.length - 1 && library[path] && library[path].length > 0) { currentLevel[part]._isLeaf = true; }
                currentLevel = currentLevel[part]._children;
            });
        });
        function createTreeDOM(node, container) {
            const keys = Object.keys(node).sort();
            keys.forEach(key => {
                const item = node[key];
                const hasChildren = Object.keys(item._children).length > 0;
                if (hasChildren) { 
                    const li = document.createElement('li'); li.className = 'tree-folder';
                    const header = document.createElement('div'); header.className = 'tree-header';
                    const titleArea = document.createElement('div'); titleArea.className = 'folder-title';
                    const countInfo = item._isLeaf ? `(${library[item._fullPath].length})` : '';
                    titleArea.innerHTML = `<span class="folder-icon">ğŸ“‚</span> ${item._name} <small style="opacity:0.6; font-weight:normal;">${countInfo}</small>`;
                    const playBtn = document.createElement('button'); playBtn.className = 'play-btn'; playBtn.innerText = 'â–¶ ì „ì²´';
                    playBtn.onclick = (e) => { e.stopPropagation(); selectDeckGroup(item._fullPath + '__'); };
                    header.appendChild(titleArea); header.appendChild(playBtn); li.appendChild(header);
                    const childContainer = document.createElement('ul'); childContainer.className = 'tree-children deck-list';
                    header.onclick = () => { childContainer.classList.toggle('open'); };
                    if (currentDeckName && currentDeckName.startsWith(item._fullPath)) { childContainer.classList.add('open'); }
                    li.appendChild(childContainer); container.appendChild(li);
                    createTreeDOM(item._children, childContainer);
                } else { 
                    const li = document.createElement('li');
                    const header = document.createElement('div');
                    header.className = `tree-deck ${item._fullPath === currentDeckName ? 'active' : ''}`;
                    header.innerHTML = `<span>ğŸ“„ ${item._name} <small>(${library[item._fullPath].length})</small></span>`;
                    const delBtn = document.createElement('button'); delBtn.className = 'del-btn'; delBtn.innerText = 'x';
                    delBtn.onclick = (e) => { e.stopPropagation(); deleteDeck(item._fullPath); };
                    header.appendChild(delBtn);
                    header.onclick = () => selectDeck(item._fullPath);
                    li.appendChild(header); container.appendChild(li);
                }
            });
        }
        createTreeDOM(tree, list);
    }

    function selectDeckGroup(prefix) {
        let mergedCards = [];
        Object.keys(library).forEach(key => { if (key.startsWith(prefix) || key === prefix.replace('__', '')) { mergedCards = mergedCards.concat(library[key]); } });
        if (mergedCards.length === 0) { const exactKey = prefix.replace(/__$/, ''); if(library[exactKey]) { selectDeck(exactKey); return; } alert("í•˜ìœ„ ë±ì´ ì—†ìŠµë‹ˆë‹¤."); return; }
        let displayName = prefix.replace(/__$/, '').split('__').pop();
        currentDeckName = prefix.replace(/__$/, ''); originalDeck = mergedCards; activeDeck = [...originalDeck];
        localStorage.setItem(STORAGE_KEY_LAST_DECK, currentDeckName);
        currentIndex = 0; isRevealed = false;
        document.getElementById('search-input').value = ''; document.getElementById('deck-title').innerText = `ğŸ“‚ ${displayName} (í†µí•© ${activeDeck.length}ê°œ)`;
        renderDeckTree(); showCard(); document.getElementById('sidebar').classList.remove('open'); document.querySelector('.sidebar-overlay').classList.remove('open');
    }

    function toggleMenu() { document.getElementById('sidebar').classList.toggle('open'); document.querySelector('.sidebar-overlay').classList.toggle('open'); }
    function filterCards() { 
        const rawQuery = document.getElementById('search-input').value.toLowerCase();
        if(!currentDeckName) return;
        if(!rawQuery) { activeDeck = [...originalDeck]; } 
        else {
            const tagMap = { 'ì¤‘ìš”': 'fav', 'ë³„': 'fav', 'ì¦ê²¨ì°¾ê¸°': 'fav', 'ì•”ê¸°': 'mem', 'ë¹„êµ': 'cmp', 'ìˆ«ì': 'num', 'ë‚ ì§œ': 'date', 'ë²Œì¹™': 'pen' };
            const tagKey = tagMap[rawQuery];
            if (tagKey) {
                const allStats = JSON.parse(localStorage.getItem(STORAGE_KEY_STATS) || '{}');
                activeDeck = originalDeck.filter(c => (allStats[c.id] || {})[tagKey]);
            } else {
                activeDeck = originalDeck.filter(card => 
                    card.q.toLowerCase().includes(rawQuery) || 
                    card.a.toLowerCase().includes(rawQuery) ||
                    (card.hiddenText && card.hiddenText.toLowerCase().includes(rawQuery))
                );
            }
        }
        currentIndex = 0; showCard(); 
    }
    function handleFileUpload(input) { const files = input.files; if(files.length === 0) return; let processedCount = 0; const edits = JSON.parse(localStorage.getItem(STORAGE_KEY_EDITS) || '{}'); Array.from(files).forEach(file => { const reader = new FileReader(); reader.onload = (e) => { const text = e.target.result; processAnkiText(text, file.name, edits); processedCount++; if (processedCount === files.length) { saveLibrary(); renderDeckTree(); if (!currentDeckName) selectDeck(Object.keys(library)[0]); alert(`ì´ ${files.length}ê°œ íŒŒì¼ ì²˜ë¦¬ë¨`); toggleMenu(); } }; reader.readAsText(file, 'UTF-8'); }); input.value = ''; }
    function saveLibrary() { try { localStorage.setItem(STORAGE_KEY_LIBRARY, JSON.stringify(library)); } catch(e){} }
    function deleteDeck(name) { if(confirm("ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) { delete library[name]; saveLibrary(); renderDeckTree(); if(currentDeckName === name) { currentDeckName=null; activeDeck=[]; showCard(); } } }
    function selectDeck(name) { if(!library[name]) return; currentDeckName = name; originalDeck = library[name]; activeDeck = [...originalDeck]; localStorage.setItem(STORAGE_KEY_LAST_DECK, name); const progress = JSON.parse(localStorage.getItem(STORAGE_KEY_PROGRESS) || '{}'); currentIndex = progress[name] || 0; if(currentIndex >= activeDeck.length) currentIndex = 0; isRevealed = false; document.getElementById('search-input').value = ''; const displayName = name.split('__').pop(); document.getElementById('deck-title').innerText = `ğŸ“„ ${displayName}`; renderDeckTree(); showCard(); document.getElementById('sidebar').classList.remove('open'); document.querySelector('.sidebar-overlay').classList.remove('open'); }
    function saveCurrentProgress() { if (!currentDeckName) return; if (!library[currentDeckName]) return; if (activeDeck.length === originalDeck.length) { const progress = JSON.parse(localStorage.getItem(STORAGE_KEY_PROGRESS) || '{}'); progress[currentDeckName] = currentIndex; localStorage.setItem(STORAGE_KEY_PROGRESS, JSON.stringify(progress)); } }
    function handleImgUpload(input) { const files = input.files; if(files.length === 0) return; imageMap.clear(); for(let file of files) { const url = URL.createObjectURL(file); imageMap.set(file.name, url); imageMap.set(file.name.normalize('NFC'), url); imageMap.set(file.name.normalize('NFD'), url); } alert(`${files.length}ê°œ ì´ë¯¸ì§€ ì—°ê²°ë¨`); showCard(); toggleMenu(); }
    function openEditModal(e) { e.stopPropagation(); if(!activeDeck || activeDeck.length === 0) return; const card = activeDeck[currentIndex]; document.getElementById('edit-q').value = card.q; document.getElementById('edit-a').value = card.a; document.getElementById('edit-modal').style.display = 'flex'; }
    function closeEditModal() { document.getElementById('edit-modal').style.display = 'none'; }
    function saveEdit() { const newQ = document.getElementById('edit-q').value; const newA = document.getElementById('edit-a').value; const card = activeDeck[currentIndex]; card.q = newQ; card.a = newA; if (location.protocol.startsWith('http')) { const edits = JSON.parse(localStorage.getItem(STORAGE_KEY_EDITS) || '{}'); edits[card.id] = { q: newQ, a: newA }; localStorage.setItem(STORAGE_KEY_EDITS, JSON.stringify(edits)); } else { saveLibrary(); } closeEditModal(); showCard(); alert("ìˆ˜ì • ì™„ë£Œ"); }
    function showCard() { if (!activeDeck || activeDeck.length === 0) { document.getElementById('question-section').innerHTML = "<h3 style='color:var(--text-sub)'>í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤.</h3>"; document.getElementById('card-info').style.display='none'; return; } if(currentIndex >= activeDeck.length) currentIndex = 0; isRevealed = false; const card = activeDeck[currentIndex]; const stats = getStats(card.id); document.getElementById('card-counter').innerText = `${currentIndex + 1} / ${activeDeck.length}`; document.getElementById('card-info').style.display='flex'; updateStatsUI(stats); updateIconsUI(stats); const qSection = document.getElementById('question-section'); qSection.innerHTML = ''; qSection.appendChild(createDOM(card.q, false)); const aSection = document.getElementById('answer-section'); aSection.innerHTML = ''; aSection.appendChild(createDOM(card.a, true)); aSection.style.display = 'none'; document.getElementById('divider').style.display = 'none'; document.getElementById('click-guide').style.display = 'block'; document.getElementById('nav-area').style.display = 'flex'; document.getElementById('grade-area').style.display = 'none'; document.getElementById('scroll-area').scrollTop = 0; }
    function revealAnswer() { isRevealed = true; document.getElementById('click-guide').style.display = 'none'; document.getElementById('divider').style.display = 'block'; document.getElementById('answer-section').style.display = 'block'; document.getElementById('grade-area').style.display = 'flex'; setTimeout(() => { document.getElementById('answer-section').scrollIntoView({ behavior: 'smooth', block: 'start' }); }, 50); }
    function moveCard(delta) { let nextIdx = currentIndex + delta; if(nextIdx >= 0 && nextIdx < activeDeck.length) { currentIndex = nextIdx; saveCurrentProgress(); showCard(); } }
    function grade(score) { saveStats(activeDeck[currentIndex].id, score); if (currentIndex < activeDeck.length - 1) { currentIndex++; saveCurrentProgress(); showCard(); } else { alert("ë!"); currentIndex=0; saveCurrentProgress(); showCard(); } }
    function getStats(id) { return JSON.parse(localStorage.getItem(STORAGE_KEY_STATS) || '{}')[id] || { correct: 0, total: 0, fav: false, mem: false, cmp: false, num: false, date: false, pen: false }; }
    function saveStats(id, score) { const data = JSON.parse(localStorage.getItem(STORAGE_KEY_STATS) || '{}'); if(!data[id]) data[id] = { correct: 0, total: 0, fav: false, mem: false, cmp: false, num: false, date: false, pen: false }; data[id].total++; if(score === 2) data[id].correct++; else if(score === 1) data[id].correct += 0.5; localStorage.setItem(STORAGE_KEY_STATS, JSON.stringify(data)); updateStatsUI(data[id]); }
    function toggleTag(e, type) { e.stopPropagation(); const card = activeDeck[currentIndex]; const data = JSON.parse(localStorage.getItem(STORAGE_KEY_STATS) || '{}'); if(!data[card.id]) data[card.id] = { correct: 0, total: 0, fav: false, mem: false, cmp: false, num: false, date: false, pen: false }; data[card.id][type] = !data[card.id][type]; localStorage.setItem(STORAGE_KEY_STATS, JSON.stringify(data)); updateIconsUI(data[card.id]); }
    function updateStatsUI(stats) { const badge = document.getElementById('rate-badge'); if(stats.total === 0) { badge.innerText = "New"; badge.className = "rate-badge"; } else { const rate = Math.round((stats.correct/stats.total)*100); badge.innerText = `${rate}% (${stats.total}íšŒ)`; badge.className = `rate-badge ${rate>=80?'high':(rate<50?'low':'')}`; } }
    function updateIconsUI(stats) { document.getElementById('mem-btn').classList.toggle('active', stats.mem); document.getElementById('cmp-btn').classList.toggle('active', stats.cmp); document.getElementById('fav-btn').classList.toggle('active', stats.fav); document.getElementById('num-btn').classList.toggle('active', stats.num); document.getElementById('date-btn').classList.toggle('active', stats.date); document.getElementById('pen-btn').classList.toggle('active', stats.pen); }
    function exportData() { const data = { stats: localStorage.getItem(STORAGE_KEY_STATS), edits: localStorage.getItem(STORAGE_KEY_EDITS), progress: localStorage.getItem(STORAGE_KEY_PROGRESS), lastDeck: localStorage.getItem(STORAGE_KEY_LAST_DECK), timestamp: new Date().toLocaleString() }; const blob = new Blob([JSON.stringify(data)], { type: "application/json" }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; const dateStr = new Date().toISOString().slice(0,10).replace(/-/g,""); a.download = `anki_backup_${dateStr}.json`; a.click(); URL.revokeObjectURL(url); }
    function importData(input) { const file = input.files[0]; if (!file) return; if(!confirm("âš ï¸ í˜„ì¬ ê¸°ê¸°ì˜ ê¸°ë¡ì„ ë®ì–´ì”Œì›ë‹ˆë‹¤.\nê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) { input.value = ''; return; } const reader = new FileReader(); reader.onload = (e) => { try { const data = JSON.parse(e.target.result); if(data.stats) localStorage.setItem(STORAGE_KEY_STATS, data.stats); if(data.edits) localStorage.setItem(STORAGE_KEY_EDITS, data.edits); if(data.progress) localStorage.setItem(STORAGE_KEY_PROGRESS, data.progress); if(data.lastDeck) localStorage.setItem(STORAGE_KEY_LAST_DECK, data.lastDeck); alert("âœ… ë³µêµ¬ ì™„ë£Œ!\ní˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•©ë‹ˆë‹¤."); location.reload(); } catch (err) { alert("âŒ ì˜ëª»ëœ ë°±ì—… íŒŒì¼ì…ë‹ˆë‹¤."); } }; reader.readAsText(file); }
    function sortCards(type) { if(!currentDeckName) return; const allStats = JSON.parse(localStorage.getItem(STORAGE_KEY_STATS) || '{}'); let newDeck = [...originalDeck]; if(type === 'rate_asc') { newDeck.sort((a,b) => { const sA = allStats[a.id] || {correct:0, total:0}; const sB = allStats[b.id] || {correct:0, total:0}; const rA = sA.total===0?100:(sA.correct/sA.total); const rB = sB.total===0?100:(sB.correct/sB.total); return rA - rB; }); alert("ğŸ”¥ ì˜¤ë‹µ ìœ„ì£¼ ì •ë ¬"); } else if (type === 'default') { } else { newDeck = newDeck.filter(c => (allStats[c.id] || {})[type]); if(newDeck.length === 0) { alert("í•´ë‹¹í•˜ëŠ” ì¹´ë“œê°€ ì—†ìŠµë‹ˆë‹¤."); return; } } activeDeck = newDeck; currentIndex = 0; showCard(); document.getElementById('sidebar').classList.remove('open'); document.querySelector('.sidebar-overlay').classList.remove('open'); }
    const cyrb53 = (str, seed = 0) => { let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed; for (let i = 0, ch; i < str.length; i++) { ch = str.charCodeAt(i); h1 = Math.imul(h1 ^ ch, 2654435761); h2 = Math.imul(h2 ^ ch, 1597334677); } h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909); return 4294967296 * (2097151 & h2) + (h1 >>> 0); };
</script>
</body>
</html>